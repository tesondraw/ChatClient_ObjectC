// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PublicUse.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "PublicUse.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - PublicUseRoot

@implementation PublicUseRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - PublicUseRoot_FileDescriptor

static GPBFileDescriptor *PublicUseRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum CMD

GPBEnumDescriptor *CMD_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CmdInit\000RequestVerifyCode\000Register\000Login"
        "\000MessageSend\000MessageRecv\000MessageServer\000E"
        "rror\000";
    static const int32_t values[] = {
        CMD_CmdInit,
        CMD_RequestVerifyCode,
        CMD_Register,
        CMD_Login,
        CMD_MessageSend,
        CMD_MessageRecv,
        CMD_MessageServer,
        CMD_Error,
    };
    static const char *extraTextFormatInfo = "\004\000c\204\000\001\021\000\006\r\000\007\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CMD)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CMD_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CMD_IsValidValue(int32_t value__) {
  switch (value__) {
    case CMD_CmdInit:
    case CMD_RequestVerifyCode:
    case CMD_Register:
    case CMD_Login:
    case CMD_MessageSend:
    case CMD_MessageRecv:
    case CMD_MessageServer:
    case CMD_Error:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ErrorCode

GPBEnumDescriptor *ErrorCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ErrorCodeInit\000AlreadyRegisterd\000NotRegist"
        "ered\000AccountOrPassword\000ServerInternal\000Pa"
        "rseData\000";
    static const int32_t values[] = {
        ErrorCode_ErrorCodeInit,
        ErrorCode_AlreadyRegisterd,
        ErrorCode_NotRegistered,
        ErrorCode_AccountOrPassword,
        ErrorCode_ServerInternal,
        ErrorCode_ParseData,
    };
    static const char *extraTextFormatInfo = "\006\000\r\000\001\020\000\002\r\000\003\021\000\004\016\000\005\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ErrorCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ErrorCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ErrorCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ErrorCode_ErrorCodeInit:
    case ErrorCode_AlreadyRegisterd:
    case ErrorCode_NotRegistered:
    case ErrorCode_AccountOrPassword:
    case ErrorCode_ServerInternal:
    case ErrorCode_ParseData:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageType

GPBEnumDescriptor *MessageType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MessageTypeInit\000Text\000Image\000Voice\000Video\000F"
        "ile\000";
    static const int32_t values[] = {
        MessageType_MessageTypeInit,
        MessageType_Text,
        MessageType_Image,
        MessageType_Voice,
        MessageType_Video,
        MessageType_File,
    };
    static const char *extraTextFormatInfo = "\006\000\017\000\001\004\000\002\005\000\003\005\000\004\005\000\005\004\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageType_MessageTypeInit:
    case MessageType_Text:
    case MessageType_Image:
    case MessageType_Voice:
    case MessageType_Video:
    case MessageType_File:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChatType

GPBEnumDescriptor *ChatType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ChatTypeInit\000Friend\000Group\000Room\000";
    static const int32_t values[] = {
        ChatType_ChatTypeInit,
        ChatType_Friend,
        ChatType_Group,
        ChatType_Room,
    };
    static const char *extraTextFormatInfo = "\004\000\014\000\001\006\000\002\005\000\003\004\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatType_ChatTypeInit:
    case ChatType_Friend:
    case ChatType_Group:
    case ChatType_Room:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - VerificationCodeReq

@implementation VerificationCodeReq

@dynamic account;

typedef struct VerificationCodeReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *account;
} VerificationCodeReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = NULL,
        .number = VerificationCodeReq_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerificationCodeReq__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerificationCodeReq class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerificationCodeReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerificationCodeRes

@implementation VerificationCodeRes

@dynamic verificationCode;

typedef struct VerificationCodeRes__storage_ {
  uint32_t _has_storage_[1];
  NSString *verificationCode;
} VerificationCodeRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "verificationCode",
        .dataTypeSpecific.className = NULL,
        .number = VerificationCodeRes_FieldNumber_VerificationCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerificationCodeRes__storage_, verificationCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerificationCodeRes class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerificationCodeRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterReq

@implementation RegisterReq

@dynamic account;
@dynamic password;
@dynamic verificationCode;

typedef struct RegisterReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *account;
  NSString *password;
  NSString *verificationCode;
} RegisterReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = NULL,
        .number = RegisterReq_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterReq__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = RegisterReq_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterReq__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verificationCode",
        .dataTypeSpecific.className = NULL,
        .number = RegisterReq_FieldNumber_VerificationCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegisterReq__storage_, verificationCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterReq class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterRes

@implementation RegisterRes

@dynamic code;

typedef struct RegisterRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
} RegisterRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = RegisterRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterRes class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginReq

@implementation LoginReq

@dynamic account;
@dynamic password;

typedef struct LoginReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *account;
  NSString *password;
} LoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = NULL,
        .number = LoginReq_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginReq__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = LoginReq_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginReq__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginReq class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginRes

@implementation LoginRes

@dynamic code;

typedef struct LoginRes__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
} LoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = LoginRes_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginRes class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GeneralResponse

@implementation GeneralResponse

@dynamic code;
@dynamic message;

typedef struct GeneralResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *message;
} GeneralResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GeneralResponse_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GeneralResponse__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = GeneralResponse_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GeneralResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GeneralResponse class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GeneralResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageContent

@implementation MessageContent

@dynamic targetId;
@dynamic senderId;
@dynamic message;
@dynamic msgType;
@dynamic resourceURL;
@dynamic chatType;

typedef struct MessageContent__storage_ {
  uint32_t _has_storage_[1];
  MessageType msgType;
  ChatType chatType;
  NSString *targetId;
  NSString *senderId;
  NSString *message;
  NSString *resourceURL;
} MessageContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageContent__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_SenderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageContent__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageContent__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.enumDescFunc = MessageType_EnumDescriptor,
        .number = MessageContent_FieldNumber_MsgType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageContent__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "resourceURL",
        .dataTypeSpecific.className = NULL,
        .number = MessageContent_FieldNumber_ResourceURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageContent__storage_, resourceURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatType",
        .dataTypeSpecific.enumDescFunc = ChatType_EnumDescriptor,
        .number = MessageContent_FieldNumber_ChatType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MessageContent__storage_, chatType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageContent class]
                                     rootClass:[PublicUseRoot class]
                                          file:PublicUseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\007A\000\002\007A\000\004\007\000\005\013\000\006\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MessageContent_MsgType_RawValue(MessageContent *message) {
  GPBDescriptor *descriptor = [MessageContent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageContent_FieldNumber_MsgType];
  return GPBGetMessageInt32Field(message, field);
}

void SetMessageContent_MsgType_RawValue(MessageContent *message, int32_t value) {
  GPBDescriptor *descriptor = [MessageContent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageContent_FieldNumber_MsgType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MessageContent_ChatType_RawValue(MessageContent *message) {
  GPBDescriptor *descriptor = [MessageContent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageContent_FieldNumber_ChatType];
  return GPBGetMessageInt32Field(message, field);
}

void SetMessageContent_ChatType_RawValue(MessageContent *message, int32_t value) {
  GPBDescriptor *descriptor = [MessageContent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MessageContent_FieldNumber_ChatType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
